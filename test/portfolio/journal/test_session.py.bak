# SPDX-License-Identifier: GPLv3
# Copyright Â© 2025 pygaindalf Rui Pinheiro

import pytest
from datetime import datetime

from app.portfolio.journal.session import Session
from app.portfolio.portfolio import Portfolio


@pytest.mark.journal
@pytest.mark.session
@pytest.mark.portfolio
class TestSessionBasics:
    def test_session_initialization_no_edits_commit_noop(self):
        s = Session(actor="tester", reason="unit test")
        assert s.actor == "tester"
        assert s.reason == "unit test"
        assert isinstance(s.start_time, datetime)
        assert s.ended is False
        assert s.edits_pending is False
        assert len(s) == 0

        # Commit on empty session should be a no-op
        s.commit()
        assert s.edits_pending is False

    @pytest.mark.xfail(raises=NotImplementedError, reason="Session commit not implemented yet for sessions with edits")
    def test_add_entity_journal_via_get(self):
        p = Portfolio()
        with p.session_manager(actor="tester", reason="add journal") as s:
            assert s.edits_pending is False
            assert len(s) == 0

            # Accessing the portfolio's journal should create an entity journal for it
            j = p.journal
            assert j.entity is p
            # Opening a journal alone no longer counts as an edit
            assert s.edits_pending is False
            assert len(s) == 1

            # Access again returns same journal (no duplication)
            j2 = p.journal
            assert j2 is j
            assert len(s) == 1

    @pytest.mark.xfail(raises=NotImplementedError, reason="Session commit not implemented yet for sessions with edits")
    def test_commit_with_edits_raises_not_implemented(self):
        p = Portfolio()
        with p.session_manager(actor="tester", reason="commit edits") as s:
            _ = p.journal  # create an entity journal (no edits yet)
            assert s.edits_pending is False
            # Perform an actual edit (attribute write) to mark edits pending
            current_ledgers = p.ledgers  # returns a JournalledMapping wrapper, not yet edited
            p.ledgers = current_ledgers  # write-through counts as an edit
            assert s.edits_pending is True
            # Explicit commit should raise NotImplementedError because implementation pending
            s.commit()

    def test_abort_clears_edits_without_ending_session(self):
        p = Portfolio()
        with p.session_manager(actor="tester", reason="abort edits") as s:
            _ = p.journal  # create entity journal (no edits yet)
            assert s.edits_pending is False
            # Actual edit
            current_ledgers = p.ledgers
            p.ledgers = current_ledgers
            assert s.edits_pending is True
            assert len(s) == 1

            s.abort()

            assert s.edits_pending is False
            assert len(s) == 0
            # Current abort() implementation does not mark session ended
            assert s.ended is False

            # Abort when already cleared should be a no-op
            s.abort()
            assert s.edits_pending is False

    def test_end_without_edits(self):
        s = Session(actor="tester", reason="end no edits")
        assert s.edits_pending is False
        s.end()  # should not raise
        assert s.ended is True

        with pytest.raises(RuntimeError):
            s.end()

    @pytest.mark.xfail(raises=NotImplementedError, reason="Session commit inside end() not implemented when edits pending")
    def test_end_with_edits_triggers_commit(self):
        p = Portfolio()

        with p.session_manager(actor="tester", reason="end with edits") as s:
            _ = p.journal  # create entity journal (no edits yet)
            assert s.edits_pending is False
            # Perform an edit
            current_ledgers = p.ledgers
            p.ledgers = current_ledgers
            assert s.edits_pending is True
            # end() should attempt commit and therefore raise NotImplementedError currently
            s.end()

    # Proxy field write tests
    @pytest.mark.xfail(raises=NotImplementedError, reason="Session commit not implemented; context exit will raise when edits pending")
    def test_field_write_through_journal_and_original_access(self):
        p = Portfolio()
        # Choose an existing field: ledgers
        assert p.dirty is False
        assert p.stale is False

        with p.session_manager(actor="tester", reason="field write") as s:
            # Access field to trigger journalled wrapper
            ledgers_proxy = p.ledgers
            assert s.edits_pending is False  # Access alone shouldn't mark edited yet (no modifications)
            # Replace entire field value
            new_value = p.ledgers  # same value for now (immutable frozendict)
            p.ledgers = new_value  # through proxy set (journal stores update)
            assert s.edits_pending is True
            assert p.dirty is True
            assert p.stale is True
            # Reading attribute returns updated value
            assert p.ledgers is ledgers_proxy or p.ledgers == new_value
            # Original value accessible via journal
            j = p.journal
            original = j.get_original_field("ledgers")
            assert original == new_value  # unchanged in this case

    def test_field_write_without_session_disallowed(self):
        p = Portfolio()
        with pytest.raises(RuntimeError):
            _ = p.journal  # requires session
        # Direct setattr outside session should succeed (no proxy interception if not in session)
        # but in this design, accessing session_manager.session is None and entity.__setattr__ should fall back
        p.ledgers = p.ledgers  # no-op
        assert p.dirty is False
        assert p.stale in (False, p.dirty)

