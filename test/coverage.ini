[run]
# Collect coverage for the 'app' package
source = app

# Collect branch coverage
branch = false

# Use test functions as the coverage context
#dynamic_context = test_function


[html]
# Change the report output directory
directory = test/htmlcov

# Show which contexts (i.e. tests) hit each line/branch
show_contexts = true


[report]
# Handle namespace packages as well when searching for non-executed files
include_namespace_packages = true

# Don't report files that are 100% covered
skip_covered = true

# Don't report files with no executable code (such as __init__.py files)
skip_empty = true

# Sort by largest miss rates
sort = Miss

# Regexes for lines to exclude from consideration
exclude_also =
    ; Don't complain about missing debug-only code:
    def __repr__
    if TYPE_CHECKING:
    if (a-z_)+.is_unit_test:
    if (a-z_)+.is_documentation_build:

    ; Don't complain if tests don't hit defensive assertion code:
    raise AssertionError
    raise NotImplementedError

    ; Don't complain if non-runnable code isn't run:
    if 0:
    if False:
    if __name__ == .__main__.:

    ; Don't complain about abstract methods and protocols, they aren't run:
    class .*\bProtocol\):
    @(abc\.)?abstractmethod

    ; Comments to turn coverage on and off:
    pragma: no cover start(?s:.)*?pragma: no cover stop
    ; A pragma comment that excludes an entire file:
    \A(?s:.*# pragma: exclude file.*)\Z

# Regexes for partial branches to exclude from consideration:
partial_also =
    ; Don't complain about branches that are only for debugging
    TYPE_CHECKING
    is_unit_test
    is_documentation_build

    ; Don't complain if non-runnable code isn't run:
    if False:
    if 0:
    if __name__ == .__main__.:

    ; Comments to turn coverage on and off:
    pragma: no cover start(?s:.)*?pragma: no cover stop
    ; A pragma comment that excludes an entire file:
    \A(?s:.*# pragma: exclude file.*)\Z